[{"sha":"485a44e2e902467da027a4a8defdf20b35114473","filename":"step-templates/sql-deploy-dacpac.json","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/OctopusDeploy/Library/blob/faa0dc7eabc47a3aa4ff848ff5cc4bc26bdb7730/step-templates/sql-deploy-dacpac.json","raw_url":"https://github.com/OctopusDeploy/Library/raw/faa0dc7eabc47a3aa4ff848ff5cc4bc26bdb7730/step-templates/sql-deploy-dacpac.json","contents_url":"https://api.github.com/repos/OctopusDeploy/Library/contents/step-templates/sql-deploy-dacpac.json?ref=faa0dc7eabc47a3aa4ff848ff5cc4bc26bdb7730","patch":"@@ -3,10 +3,10 @@\n   \"Name\": \"SQL - Deploy DACPAC\",\n   \"Description\": \"Calls the DacFX library to perform SSDT commands such as:\\n * Deploy\\n * Script\\n * DeployReport\\n\\nIf selected the deploy script and deploy report will be loaded back into Octopus Deploy as an artifact. This allows you to put in place  manual intervention step if required. It is also useful for auditing purposes.\\n\\nSqlCmd variables are now supported.  To specify SqlCmd variables, create your Octopus variable with the following naming convention: SqlCmdVariable.<Variable name> (case insensitive) and then assign it a value.  Examples:\\n* SqlCmdVariable.Variable1\\n* my.sqlcmdvariable.variable2\",\n   \"ActionType\": \"Octopus.Script\",\n-  \"Version\": 12,\n+  \"Version\": 13,\n   \"Properties\": {\n     \"Octopus.Action.Script.Syntax\": \"PowerShell\",\n-    \"Octopus.Action.Script.ScriptBody\": \"<#\\n .SYNOPSIS\\n Converts boolean values to boolean types\\n\\n .DESCRIPTION\\n Converts boolean values to boolean types\\n\\n .PARAMETER Value\\n The value to convert\\n\\n .EXAMPLE\\n Format-OctopusArgument \\\"true\\\"\\n#>\\nFunction Format-OctopusArgument {\\n\\n\\tParam(\\n\\t\\t[string]$Value\\n\\t)\\n\\n\\t$Value = $Value.Trim()\\n\\n\\t# There must be a better way to do this\\n\\tSwitch -Wildcard ($Value){\\n\\n\\t\\t\\\"True\\\" { Return $True }\\n\\t\\t\\\"False\\\" { Return $False }\\n\\t\\t\\\"#{*}\\\" { Return $null }\\n\\t\\tDefault { Return $Value }\\n\\t}\\n}\\n\\n<#\\n .SYNOPSIS\\n Removes invalid file name characters\\n\\n .DESCRIPTION\\n Removes invalid file name characters\\n\\n .PARAMETER FileName\\n The file name to removes the invalid characters in\\n\\n .EXAMPLE\\nRemove-InvalidFileNameChars -FileName \\\"Not\\\\Allowed\\\"\\n#>\\nFunction Remove-InvalidFileNameChars {\\n\\n\\tParam(\\n\\t\\t[string]$FileName\\n\\t)\\n\\n\\t[IO.Path]::GetinvalidFileNameChars() | ForEach-Object { $FileName = $FileName.Replace($_, \\\"_\\\") }\\n\\tReturn $FileName\\n}\\n\\n<#\\n .SYNOPSIS\\n Finds the DAC File that you specify\\n\\n .DESCRIPTION\\n Looks through the supplied PathList array and searches for the file you specify.  It will return the first one that it finds.\\n\\n .PARAMETER FileName\\n Name of the file you are looking for\\n\\n .PARAMETER PathList\\n Array of Paths to search through.\\n\\n .EXAMPLE\\n Find-DacFile -FileName \\\"Microsoft.SqlServer.TransactSql.ScriptDom.dll\\\" -PathList @(\\\"${env:ProgramFiles}\\\\Microsoft SQL Server\\\", \\\"${env:ProgramFiles(x86)}\\\\Microsoft SQL Server\\\")\\n#>\\nFunction Find-DacFile {\\n\\tParam(\\n\\t\\t[Parameter(Mandatory=$true)]\\n\\t\\t[string]$FileName,\\n\\t\\t[Parameter(Mandatory=$true)]\\n\\t\\t[string[]]$PathList\\n\\t)\\n\\n\\t$File = $null\\n\\n\\tForEach($Path in $PathList)\\n\\t{\\n\\t\\tWrite-Debug (\\\"Searching: {0}\\\" -f $Path)\\n\\n\\t\\tIf (!($File))\\n\\t\\t{\\n\\t\\t\\t$File = (\\n\\t\\t\\t\\tGet-ChildItem $Path -ErrorAction SilentlyContinue -Filter $FileName -Recurse |\\n\\t\\t\\t\\tSort-Object FullName -Descending |\\n\\t\\t\\t\\tSelect -First 1\\n\\t\\t\\t\\t)\\n\\n\\t\\t\\tIf ($File)\\n\\t\\t\\t{\\n\\t\\t\\t\\tWrite-Debug (\\\"Found: {0}\\\" -f $File.FullName)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tReturn $File\\n}\\n\\n<#\\n .SYNOPSIS\\n Adds the required types so that they can be used\\n\\n .DESCRIPTION\\n Adds the DacFX types that are required to do database deploys, scripts and deployment reports from SSDT\\n\\n .EXAMPLE\\n Add-DACAssemblies\\n#>\\nFunction Add-DACAssemblies {\\n\\n\\tWrite-Verbose \\\"Loading the DacFX Assemblies\\\"\\n\\n\\t$SearchPathList = @(\\\"${env:ProgramFiles}\\\\Microsoft SQL Server\\\\$TargetDatabaseVersion\\\", \\\"${env:ProgramFiles(x86)}\\\\Microsoft SQL Server\\\\$TargetDatabaseVersion\\\")\\n\\n\\tWrite-Debug \\\"Searching for: Microsoft.SqlServer.TransactSql.ScriptDom.dll\\\"\\n\\t$ScriptDomDLL = (Find-DacFile -FileName \\\"Microsoft.SqlServer.TransactSql.ScriptDom.dll\\\" -PathList $SearchPathList)\\n\\n\\tWrite-Debug \\\"Searching for: Microsoft.SqlServer.Dac.dll\\\"\\n\\t$DacDLL = (Find-DacFile -FileName \\\"Microsoft.SqlServer.Dac.dll\\\" -PathList $SearchPathList)\\n\\n\\tIf (!($ScriptDomDLL))\\n\\t{\\n\\t\\tThrow \\\"Could not find the file: Microsoft.SqlServer.TransactSql.ScriptDom.dll\\\"\\n\\t}\\n\\tIf (!($DacDLL))\\n\\t{\\n\\t\\tThrow \\\"Could not find the file: Microsoft.SqlServer.Dac.dll\\\"\\n\\t}\\n\\n\\tWrite-Debug (\\\"Adding the type: {0}\\\" -f $ScriptDomDLL.FullName)\\n\\tAdd-Type -Path $ScriptDomDLL.FullName\\n\\n\\tWrite-Debug (\\\"Adding the type: {0}\\\" -f $DacDLL.FullName)\\n\\tAdd-Type -Path $DacDLL.FullName\\n\\n\\tWrite-Host \\\"Loaded the DAC assemblies\\\"\\n}\\n\\n\\n<#\\n .SYNOPSIS\\n Generates a connection string\\n\\n .DESCRIPTION\\n Derive a connection string from the supplied variables\\n\\n .PARAMETER ServerName\\n Name of the server to connect to\\n\\n .PARAMETER Database\\n Name of the database to connect to\\n\\n .PARAMETER UseIntegratedSecurity\\n Boolean value to indicate if Integrated Security should be used or not\\n\\n .PARAMETER UserName\\n User name to use if we are not using integrated security\\n\\n .PASSWORD Password\\n Password to use if we are not using integrated security\\n\\n .PARAMETER EnableMultiSubnetFailover\\n Flag as to whether we should enable multi subnet failover\\n\\n .EXAMPLE\\n Get-ConnectionString -ServerName localhost -UseIntegratedSecurity -Database OctopusDeploy\\n\\n .EXAMPLE\\n Get-ConnectionString -ServerName localhost -UserName sa -Password ProbablyNotSecure -Database OctopusDeploy\\n#>\\nFunction Get-ConnectionString {\\n\\tParam(\\n\\t\\t[Parameter(Mandatory=$True)]\\n\\t\\t[string]$ServerName,\\n\\t\\t[bool]$UseIntegratedSecurity,\\n\\t\\t[string]$UserName,\\n\\t\\t[string]$Password,\\n\\t\\t[bool]$EnableMultiSubnetFailover,\\n\\t\\t[string]$Database\\n\\t)\\n\\n\\t$ApplicationName = \\\"OctopusDeploy\\\"\\n\\t$connectionString = (\\\"Application Name={0};Server={1}\\\" -f $ApplicationName, $ServerName)\\n\\n\\tIf ($UseIntegratedSecurity)\\n\\t{\\n\\t\\tWrite-Verbose \\\"Using integrated security\\\"\\n\\t\\t$connectionString += \\\";Trusted_Connection=True\\\"\\n\\t}\\n\\tElse{\\n\\t\\tWrite-Verbose \\\"Using standard security\\\"\\n\\t\\t$connectionString += (\\\";Uid={0};Pwd={1}\\\" -f $UserName, $Password)\\n\\t}\\n\\n\\tif ($EnableMultiSubnetFailover)\\n\\t{\\n\\t\\tWrite-Verbose \\\"Enabling multi subnet failover\\\"\\n\\t\\t$connectionString += \\\";MultisubnetFailover=True\\\"\\n\\t}\\n\\n\\tIf ($Database)\\n\\t{\\n\\t\\t$connectionString += (\\\";Initial Catalog={0}\\\" -f $Database)\\n\\t}\\n\\n\\tReturn $connectionString\\n}\\n\\nFunction Get-SQLServerVersion {\\n    Param(\\n        [string]$serverVersion\\n    )\\n    \\n    $serverVersion = $serverVersion.Trim()\\n    \\n    Switch ($serverVersion){\\n\\t\\t\\\"100\\\" { Return \\\"SQL Server 2008\\\" }\\n\\t\\t\\\"110\\\" { Return \\\"SQL Server 2012\\\" }\\n\\t\\t\\\"120\\\" { Return \\\"SQL Server 2014\\\" }\\n\\t\\t\\\"130\\\" { Return \\\"SQL Server 2016\\\" }\\n        \\\"140\\\" { Return \\\"SQL Server 2017\\\" }\\n\\t\\tDefault { Return $null }\\n    }\\n}\\n\\n<#\\n .SYNOPSIS\\n Invokes the DacPac utility\\n\\n .DESCRIPTION\\n Used to invoke the actions against the DacFx library.  This utility can generate deployment reports, deployment scripts and execute a deploy\\n\\n .PARAMETER Report\\n Boolean flag as to whether a deploy report should be generated\\n\\n .PARAMETER Script\\n Boolean flag as to whether a deployment script should be generated\\n\\n .PARAMETER Deploy\\n Boolean flag as to whether a deployment should occur\\n\\n .PARAMETER DacPacFilename\\n Full path as to where we can find the DacPac to use\\n\\n .PARAMETER TargetServer\\n Name of the server to run the DacPac against\\n\\n .PARAMETER TargetDatabase\\n Name of the database to run the DacPac against\\n\\n .PARAMETER UseIntegratedSecurity\\n Flag as to whether we should use integrate security or not\\n\\n .PARAMETER EnableMultiSubnetFailover\\n Flag as to whether we should enable multi subnet failover\\n\\n .PARAMETER UserName\\n If we are not using integrated security, we should use this user name to connect to the server\\n\\n .PARAMETER Password\\n If we are not using integrated security, we should use this password to connect to the server\\n\\n .PARAMETER PublishProfile\\n Full path to the publish profile we should use\\n\\n .EXAMPLE\\n Invoke-DacPacUtility\\n\\n#>\\nFunction Invoke-DacPacUtility {\\n\\n\\tParam(\\n\\t\\t[bool]$Report,\\n\\t\\t[bool]$Script,\\n\\t\\t[bool]$Deploy,\\n\\t\\t[bool]$ExtractTargetDatabaseDacpac,\\n\\t\\t[string]$DacPacFilename,\\n\\t\\t[string]$TargetServer,\\n\\t\\t[string]$TargetDatabase,\\n\\t\\t[bool]$UseIntegratedSecurity,\\n\\t\\t[string]$UserName,\\n\\t\\t[string]$Password,\\n\\t\\t[bool]$EnableMultiSubnetFailover,\\n\\t\\t[string]$PublishProfile,\\n\\t\\t[string]$AdditionalDeploymentContributors,\\n\\t\\t[string]$AdditionalDeploymentContributorArguments\\n\\t)\\n\\n\\t# We output the parameters (excluding password) so that we can see what was supplied for debuging if required.  Useful for variable scoping problems\\n\\tWrite-Debug (\\\"Invoke-DacPacUtility called.  Parameter values supplied:\\\")\\n\\tWrite-Debug (\\\"    Dacpac Filename:                  {0}\\\" -f $DacPacFilename)\\n\\tWrite-Debug (\\\"    Dacpac Profile:                   {0}\\\" -f $PublishProfile)\\n\\tWrite-Debug (\\\"    Target server:                    {0}\\\" -f $TargetServer)\\n\\tWrite-Debug (\\\"    Target database:                  {0}\\\" -f $TargetDatabase)\\n\\tWrite-Debug (\\\"    Target database version:          {0}\\\" -f (Get-SQLServerVersion $TargetDatabaseVersion))\\n\\tWrite-Debug (\\\"    Using integrated security:        {0}\\\" -f $UseIntegratedSecurity)\\n\\tWrite-Debug (\\\"    Username:                         {0}\\\" -f $UserName)\\n\\tWrite-Debug (\\\"    Enable multi subnet failover      {0}\\\" -f $EnableMultiSubnetFailover)\\n\\tWrite-Debug (\\\"    Report:                           {0}\\\" -f $Report)\\n\\tWrite-Debug (\\\"    Script:                           {0}\\\" -f $Script)\\n\\tWrite-Debug (\\\"    Deploy:                           {0}\\\" -f $Deploy)\\n\\tWrite-Debug (\\\"    Extract target database dacpac    {0}\\\" -f $ExtractTargetDatabaseDacpac)\\n\\tWrite-Debug (\\\"    Deployment contributors:          {0}\\\" -f $AdditionalDeploymentContributors)\\n\\tWrite-Debug (\\\"    Deployment contributor arguments: {0}\\\" -f $AdditionalDeploymentContributorArguments)\\n\\n\\t$DateTime = ((Get-Date).ToUniversalTime().ToString(\\\"yyyyMMddHHmmss\\\"))\\n\\n\\tAdd-DACAssemblies\\n\\n\\tTry {\\n\\t\\t$dacPac = [Microsoft.SqlServer.Dac.DacPackage]::Load($DacPacFilename)\\n\\t\\t$connectionString = (Get-ConnectionString -ServerName $TargetServer -Database $TargetDatabase -UseIntegratedSecurity $UseIntegratedSecurity -EnableMultiSubnetFailover $EnableMultiSubnetFailover -UserName $UserName -Password $Password)\\n\\n\\t\\t# Load the publish profile if supplied\\n\\t\\tIf ($PublishProfile)\\n\\t\\t{\\n\\t\\t\\tWrite-Verbose (\\\"Attempting to load the publish profile: {0}\\\" -f $PublishProfile)\\n\\n\\t\\t\\t#Load the publish profile\\n\\t\\t\\t$dacProfile = [Microsoft.SqlServer.Dac.DacProfile]::Load($PublishProfile)\\n\\t\\t\\tWrite-Verbose (\\\"Loaded publish profile: {0}\\\" -f $PublishProfile)\\n\\n            if([string]::IsNullOrWhiteSpace($dacProfile.TargetConnectionString) -ne $true) {\\n               Write-Warning \\\"Publish profile contains a TargetConnectionString setting. This setting might override the connection settings specified as command line parameters when using .NET classes from the Microsoft.SqlServer.Dac namespace.\\\"\\n            }\\n\\n\\t\\t\\t#Load the artifact back into Octopus Deploy\\n\\t\\t\\t$profileArtifact = Remove-InvalidFileNameChars -FileName (\\\"{0}.{1}.{2}.{3}\\\" -f $TargetServer, $TargetDatabase, $DateTime, ($PublishProfile.Remove(0, $PublishProfile.LastIndexOf(\\\"\\\\\\\") + 1)))\\n\\t\\t\\tNew-OctopusArtifact -Path $PublishProfile -Name $profileArtifact\\n\\t\\t\\tWrite-Verbose (\\\"Loaded publish profile as an Octopus Deploy artifact\\\")\\n\\t\\t}\\n\\t\\tElse {\\n\\t\\t\\t$dacProfile = New-Object Microsoft.SqlServer.Dac.DacProfile\\n\\t\\t\\tWrite-Verbose (\\\"Created blank publish profile\\\")\\n\\t\\t}\\n\\n\\t\\t# Specify additional deployment contributors:\\n\\t\\tif($AdditionalDeploymentContributors) {\\n\\t\\t    $dacProfile.DeployOptions.AdditionalDeploymentContributors = $AdditionalDeploymentContributors\\n\\t\\t}\\n\\t\\t\\n\\t\\tif($AdditionalDeploymentContributorArguments) {\\n\\t\\t    $dacProfile.DeployOptions.AdditionalDeploymentContributorArguments = $AdditionalDeploymentContributorArguments\\n\\t\\t}\\n\\n\\t\\t$dacServices = New-Object Microsoft.SqlServer.Dac.DacServices -ArgumentList $connectionString\\n\\n\\t\\t# Register the object events and output them to the verbose stream\\n\\t\\tRegister-ObjectEvent -InputObject $dacServices -EventName \\\"ProgressChanged\\\" -SourceIdentifier \\\"ProgressChanged\\\" -Action { Write-Verbose (\\\"DacServices: {0}\\\" -f $EventArgs.Message) } | Out-Null\\n\\t\\tRegister-ObjectEvent -InputObject $dacServices -EventName \\\"Message\\\" -SourceIdentifier \\\"Message\\\" -Action { Write-Host ($EventArgs.Message.Message) } | Out-Null\\n\\n\\t\\t# Get all SqlCmdVariables\\n        $sqlCmdVariables = $OctopusParameters.Keys -imatch \\\"SqlCmdVariable.*\\\"\\n        \\n        # Check to see if something is there\\n        if ($null -ne $sqlCmdVariables)\\n        {\\n        \\tWrite-Output \\\"Adding SqlCmdVariables ...\\\"\\n            \\n            # Check to see if the deploy options property is null\\n            if ($null -eq $dacProfile.DeployOptions)\\n            {\\n            \\t# Create new Microsoft.SqlServer.Dac.DacDeployOptions object\\n                $dacProfile.DeployOptions = New-Object Microsoft.SqlServer.Dac.DacDeployOptions\\n            }\\n            \\n            # Loop through the variable collection\\n            foreach ($sqlCmdVariable in $sqlCmdVariables)\\n            {\\n            \\t# Add variable to the deploy options\\n                $sqlCmdVariableKey = $sqlCmdVariable.Substring(($sqlCmdVariable.ToLower().IndexOf(\\\"sqlcmdvariable.\\\") + \\\"sqlcmdvariable.\\\".Length))\\n                \\n                Write-Output \\\"Adding variable: $sqlCmdVariableKey with value: $($OctopusParameters[$sqlCmdVariable])\\\"\\n                \\n                $dacProfile.DeployOptions.SqlCommandVariableValues.Add($sqlCmdVariableKey, $OctopusParameters[$sqlCmdVariable])\\n            }\\n        }\\n\\t\\n\\t\\tIf ($Report -or $Script -or $ExtractTargetDatabaseDacpac)\\n\\t\\t{\\n\\t\\t\\t# Extract a DACPAC so we can do reports and scripting faster (if both are done)\\n\\t\\t\\t# dbDacPac\\n\\t\\t\\t$dbDacPacFilename = Remove-InvalidFileNameChars -FileName (\\\"{0}.{1}.{2}.dacpac\\\" -f $TargetServer, $TargetDatabase, $DateTime)\\n            \\n            $dbDacPacFilepath = $InstallPath + \\\"\\\\\\\" + $dbDacPacFilename\\n\\t\\t\\t$dacVersion = New-Object System.Version(1, 0, 0, 0)\\n\\t\\t\\tWrite-Debug \\\"Extracting target server dacpac\\\"\\n\\t\\t\\t\\n            # Extract-Method needs full file-path in order to work\\n            $dacServices.Extract($dbDacPacFilepath, $TargetDatabase, $TargetDatabase, $dacVersion)\\n\\n\\t\\t\\tWrite-Debug (\\\"Loading the target server dacpac for report and scripting. Filename: {0}\\\" -f $dbDacPacFilepath)\\n\\t\\t\\t$dbDacPac = [Microsoft.SqlServer.Dac.DacPackage]::Load($dbDacPacFilepath)\\n\\n\\t\\t\\tIf ($ExtractTargetDatabaseDacpac)\\n\\t\\t\\t{\\n\\t\\t\\t\\tNew-OctopusArtifact -Path $dbDacPacFilepath -Name $dbDacPacFilepath\\n\\t\\t\\t}\\n\\n\\t\\t\\t# Generate a Deploy Report if one is asked for\\n\\t\\t\\tIf ($Report)\\n\\t\\t\\t{\\n\\t\\t\\t\\tWrite-Host (\\\"Generating deploy report against server: {0}, database: {1}\\\" -f $TargetServer, $TargetDatabase)\\n\\t\\t\\t\\t$deployReport = [Microsoft.SqlServer.Dac.DacServices]::GenerateDeployReport($dacPac, $dbDacPac, $TargetDatabase, $dacProfile.DeployOptions)\\n\\t\\t\\t\\t$reportArtifact = Remove-InvalidFileNameChars -FileName (\\\"{0}.{1}.{2}.{3}\\\" -f $TargetServer, $TargetDatabase, $DateTime, \\\"DeployReport.xml\\\")\\n\\t\\t\\n\\t\\t\\t\\tSet-Content $reportArtifact $deployReport\\n\\n\\t\\t\\t\\tWrite-Host (\\\"Loading the deploy report to OctopusDeploy: {0}\\\" -f $reportArtifact)\\n\\t\\t\\t\\tNew-OctopusArtifact -Path $reportArtifact -Name $reportArtifact\\n\\t\\t\\t}\\n\\n\\t\\t\\t# Generate a Deploy Script if one is asked for\\n\\t\\t\\tIf ($Script)\\n\\t\\t\\t{\\n\\t\\t\\t\\tWrite-Host (\\\"Generating deploy script against server: {0}, database: {1}\\\" -f $TargetServer, $TargetDatabase)\\n\\t\\t\\t\\t$deployScript = [Microsoft.SqlServer.Dac.DacServices]::GenerateDeployScript($dacPac, $dbDacPac, $TargetDatabase, $dacProfile.DeployOptions)\\n\\t\\t\\t\\t$scriptArtifact = Remove-InvalidFileNameChars -FileName (\\\"{0}.{1}.{2}.{3}\\\" -f $TargetServer, $TargetDatabase, $DateTime, \\\"DeployScript.sql\\\")\\n\\t\\t\\n\\t\\t\\t\\tSet-Content $scriptArtifact $deployScript\\n\\t\\t\\n\\t\\t\\t\\tWrite-Host (\\\"Loading the deploy script to OctopusDeploy: {0}\\\" -f $scriptArtifact)\\n\\t\\t\\t\\tNew-OctopusArtifact -Path $scriptArtifact -Name $scriptArtifact\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\t# Deploy the dacpac if asked for\\n\\t\\tIf ($Deploy)\\n\\t\\t{\\n\\t\\t\\tWrite-Host (\\\"Starting deployment of dacpac against server: {0}, database: {1}\\\" -f $TargetServer, $TargetDatabase)\\n\\t\\t\\t$dacServices.Deploy($dacPac, $TargetDatabase, $true, $dacProfile.DeployOptions, $null)\\n\\t\\t\\n\\t\\t\\tWrite-Host (\\\"Dacpac deployment complete\\\")\\n\\t\\t}\\n\\t\\t\\n\\t\\tUnregister-Event -SourceIdentifier \\\"ProgressChanged\\\"\\n\\t\\tUnregister-Event -SourceIdentifier \\\"Message\\\"\\n\\t}\\n\\tCatch {\\n\\t\\t# If we use Write-Error here the original exception will be overwritten by a WriteErrorException\\n        Write-Debug (\\\"An exception of type {0} was thrown.\\\" -f $_.Exception.GetType().FullName)\\n        Write-Debug (\\\"Deployment failed: {0} `r`nReason: {1}\\\" -f $_.Exception.Message, $_.Exception.InnerException.Message)\\n\\n        # re-throw in order to not lose inner exceptions and stack trace that are generated by\\n        # the invocation of the .NET classes from Microsoft.SqlServer.Dac\\n        throw\\n\\t}\\n}\\n\\n<#\\n.SYNOPSIS\\n    Determines the install location of the DACPAC package.\\n.DESCRIPTION\\n    Determines the install location of the DACPAC package.\\n.PARAMETER PackageStepName\\n    The name of the package step which installs the DACPAC.\\n#>\\nfunction Get-DacpacInstallPath\\n{\\n    [CmdletBinding()]\\n    Param\\n    (\\n        [Parameter(Mandatory=$true)]\\n        [String]$PackageStepName\\n    )\\n\\n    try\\n    {\\n        # Attempt to retrieve the install path from the package step.\\n        $InstallPathKey = (\\\"Octopus.Action[{0}].Output.Package.InstallationDirectoryPath\\\" -f $DACPACPackageStep)\\n        $InstallPath = $OctopusParameters[$InstallPathKey]\\n        if ($InstallPath -ne $null) {\\n            Write-Verbose (\\\"Install path determined from '{0}' output variables as '{1}'.\\\" -f $PackageStepName, $InstallPath)\\n            return $InstallPath\\n        }\\n\\n        # Install path hasn't been found yet so try to determine the path from the parameters of the package step.\\n        $InstallPathCustomDirectoryKey = (\\\"Octopus.Action[{0}].Package.CustomInstallationDirectory\\\" -f $DACPACPackageStep)\\n        $InstallPath = $OctopusParameters[$InstallPathCustomDirectoryKey]\\n        if ($InstallPath -ne $null) {\\n            Write-Verbose (\\\"Install path determined from '{0}' custom installation directory parameter as '{1}'.\\\" -f $PackageStepName, $InstallPath)\\n            return $InstallPath\\n        }\\n\\n        # Install path hasn't been found yet so try to determine the path from the parameters of the package step.\\n        $PackageIdKey = (\\\"Octopus.Action[{0}].Package.PackageId\\\" -f $DACPACPackageStep)\\n        $PackageId = $OctopusParameters[$PackageIdKey]\\n\\n        $PackageVersionKey = (\\\"Octopus.Action[{0}].Package.PackageVersion\\\" -f $DACPACPackageStep)\\n        $PackageVersion = $OctopusParameters[$PackageVersionKey]\\n\\n        if ($PackageVersion -ne $null -and $PackageId -ne $null) {\\n            $AgentApplicationDirectoryPath = $OctopusParameters[\\\"Octopus.Tentacle.Agent.ApplicationDirectoryPath\\\"]\\n            $TenantName = $OctopusParameters[\\\"Octopus.Deployment.Tenant.Name\\\"]\\n            $EnvironmentName = $OctopusParameters[\\\"Octopus.Environment.Name\\\"]\\n\\n            $InstallPath = Join-Path $AgentApplicationDirectoryPath \\\"$TenantName\\\\$EnvironmentName\\\\$PackageId\\\\$PackageVersion\\\"\\n\\n            Write-Verbose (\\\"Install path calculated using default path from '{0}' parameters as '{1}'.\\\" -f $PackageStepName, $InstallPath)\\n            return $InstallPath\\n        }\\n\\n        throw \\\"Could not determine the install location of the package.\\\"\\n    }\\n    catch\\n    {\\n        $_ | Format-List -Force | Out-String | Write-Debug;\\n        throw;\\n    }\\n}\\n\\n# Get the supplied parameters\\n$DACPACPackageStep = $OctopusParameters[\\\"DACPACPackageStep\\\"]\\n$DACPACPackageName = $OctopusParameters[\\\"DACPACPackageName\\\"]\\n$PublishProfile = $OctopusParameters[\\\"DACPACPublishProfile\\\"]\\n$Report = Format-OctopusArgument -Value $OctopusParameters[\\\"Report\\\"]\\n$Script = Format-OctopusArgument -Value $OctopusParameters[\\\"Script\\\"]\\n$Deploy = Format-OctopusArgument -Value $OctopusParameters[\\\"Deploy\\\"]\\n$ExtractTargetDatabaseDacpac = Format-OctopusArgument -Value $OctopusParameters[\\\"ExtractTargetDatabaseDacPac\\\"]\\n$TargetServer = $OctopusParameters[\\\"TargetServer\\\"]\\n$TargetDatabase = $OctopusParameters[\\\"TargetDatabase\\\"]\\n$TargetDatabaseVersion = $OctopusParameters[\\\"TargetDatabaseVersion\\\"]\\n$UseIntegratedSecurity = Format-OctopusArgument -Value $OctopusParameters[\\\"UseIntegratedSecurity\\\"]\\n$Username = $OctopusParameters[\\\"SQLUsername\\\"]\\n$Password = $OctopusParameters[\\\"SQLPassword\\\"]\\n$EnableMultiSubnetFailover = Format-OctopusArgument -Value $OctopusParameters[\\\"EnableMultiSubnetFailover\\\"]\\n$AdditionalDeploymentContributors = Format-OctopusArgument -Value $OctopusParameters[\\\"AdditionalContributors\\\"]\\n$AdditionalDeploymentContributorArguments = Format-OctopusArgument -Value $OctopusParameters[\\\"AdditionalContributorArguments\\\"]\\n\\n$InstallPath = Get-DacpacInstallPath -PackageStepName $DACPACPackageStep\\nif(!(Test-Path $InstallPath)) {\\n    Throw (\\\"The package extraction folder '{0}' does not exist or the Octopus Tentacle does not have permission to access it.\\\" -f $InstallPath)\\n}\\n\\n# Expand the publish dacpac filename\\n$DACPACPackageName = ($InstallPath + \\\"\\\\\\\" + $DACPACPackageName)\\nif(!(Test-Path $DACPACPackageName)) {\\n    Throw (\\\"Could not find the file '{0}'\\\" -f $DACPACPackageName)\\n}\\n\\n# Expand the publish profile filename if a value has been supplied\\nIf ($PublishProfile)\\n{\\n    $PublishProfile = ($InstallPath + \\\"\\\\\\\" + $PublishProfile)\\n    if(!(Test-Path $PublishProfile)) {\\n        Throw (\\\"Could not find the file '{0}'\\\" -f $PublishProfile)\\n    }\\n}\\n\\n# Invoke the DacPac utility\\ntry\\n{\\n    Invoke-DacPacUtility -Report $Report -Script $Script -Deploy $Deploy -ExtractTargetDatabaseDacpac $ExtractTargetDatabaseDacpac -DacPacFilename $DACPACPackageName -TargetServer $TargetServer -TargetDatabase $TargetDatabase -UseIntegratedSecurity $UseIntegratedSecurity -Username $Username -Password $Password -EnableMultiSubnetFailover $EnableMultiSubnetFailover -PublishProfile $PublishProfile -AdditionalDeploymentContributors $AdditionalDeploymentContributors -AdditionalDeploymentContributorArguments $AdditionalDeploymentContributorArguments\\n}\\ncatch\\n{\\n    Write-Host $_.Exception.ToString()\\n    throw;\\n}\\n\",\n+    \"Octopus.Action.Script.ScriptBody\": \"function Get-ModuleInstalled\\n{\\n    # Define parameters\\n    param(\\n        $PowerShellModuleName\\n    )\\n\\n    # Check to see if the module is installed\\n    if ($null -ne (Get-Module -ListAvailable -Name $PowerShellModuleName))\\n    {\\n        # It is installed\\n        return $true\\n    }\\n    else\\n    {\\n        # Module not installed\\n        return $false\\n    }\\n}\\n\\nfunction Get-NugetPackageProviderNotInstalled\\n{\\n\\t# See if the nuget package provider has been installed\\n    return ($null -eq (Get-PackageProvider -ListAvailable -Name Nuget -ErrorAction SilentlyContinue))\\n}\\n\\nfunction Install-PowerShellModule\\n{\\n    # Define parameters\\n    param(\\n        $PowerShellModuleName,\\n        $LocalModulesPath\\n    )\\n\\n\\t# Check to see if the package provider has been installed\\n    if ((Get-NugetPackageProviderNotInstalled) -ne $false)\\n    {\\n    \\t# Display that we need the nuget package provider\\n        Write-Host \\\"Nuget package provider not found, installing ...\\\"\\n        \\n        # Install Nuget package provider\\n        Install-PackageProvider -Name Nuget -Force\\n    }\\n\\n\\t# Save the module in the temporary location\\n    Save-Module -Name $PowerShellModuleName -Path $LocalModulesPath -Force\\n\\n}\\n\\nFunction Load-SqlServerAssmblies\\n{\\n\\t# Declare parameters\\n    \\n\\t# Get the folder where the SqlServer module ended up in\\n\\t$sqlServerModulePath = [System.IO.Path]::GetDirectoryName((Get-Module SqlServer).Path)\\n    \\n    # Loop through the assemblies\\n    foreach($assemblyFile in (Get-ChildItem -Path $sqlServerModulePath -Exclude msv*.dll | Where-Object {$_.Extension -eq \\\".dll\\\"}))\\n    {\\n        # Load the assembly\\n        [Reflection.Assembly]::LoadFile($assemblyFile.FullName) | Out-Null\\n    }    \\n}\\n\\n\\n<#\\n .SYNOPSIS\\n Converts boolean values to boolean types\\n\\n .DESCRIPTION\\n Converts boolean values to boolean types\\n\\n .PARAMETER Value\\n The value to convert\\n\\n .EXAMPLE\\n Format-OctopusArgument \\\"true\\\"\\n#>\\nFunction Format-OctopusArgument {\\n\\n\\tParam(\\n\\t\\t[string]$Value\\n\\t)\\n\\n\\t$Value = $Value.Trim()\\n\\n\\t# There must be a better way to do this\\n\\tSwitch -Wildcard ($Value){\\n\\n\\t\\t\\\"True\\\" { Return $True }\\n\\t\\t\\\"False\\\" { Return $False }\\n\\t\\t\\\"#{*}\\\" { Return $null }\\n\\t\\tDefault { Return $Value }\\n\\t}\\n}\\n\\n<#\\n .SYNOPSIS\\n Removes invalid file name characters\\n\\n .DESCRIPTION\\n Removes invalid file name characters\\n\\n .PARAMETER FileName\\n The file name to removes the invalid characters in\\n\\n .EXAMPLE\\nRemove-InvalidFileNameChars -FileName \\\"Not\\\\Allowed\\\"\\n#>\\nFunction Remove-InvalidFileNameChars {\\n\\n\\tParam(\\n\\t\\t[string]$FileName\\n\\t)\\n\\n\\t[IO.Path]::GetinvalidFileNameChars() | ForEach-Object { $FileName = $FileName.Replace($_, \\\"_\\\") }\\n\\tReturn $FileName\\n}\\n\\n<#\\n .SYNOPSIS\\n Finds the DAC File that you specify\\n\\n .DESCRIPTION\\n Looks through the supplied PathList array and searches for the file you specify.  It will return the first one that it finds.\\n\\n .PARAMETER FileName\\n Name of the file you are looking for\\n\\n .PARAMETER PathList\\n Array of Paths to search through.\\n\\n .EXAMPLE\\n Find-DacFile -FileName \\\"Microsoft.SqlServer.TransactSql.ScriptDom.dll\\\" -PathList @(\\\"${env:ProgramFiles}\\\\Microsoft SQL Server\\\", \\\"${env:ProgramFiles(x86)}\\\\Microsoft SQL Server\\\")\\n#>\\nFunction Find-DacFile {\\n\\tParam(\\n\\t\\t[Parameter(Mandatory=$true)]\\n\\t\\t[string]$FileName,\\n\\t\\t[Parameter(Mandatory=$true)]\\n\\t\\t[string[]]$PathList\\n\\t)\\n\\n\\t$File = $null\\n\\n\\tForEach($Path in $PathList)\\n\\t{\\n\\t\\tWrite-Debug (\\\"Searching: {0}\\\" -f $Path)\\n\\n\\t\\tIf (!($File))\\n\\t\\t{\\n\\t\\t\\t$File = (\\n\\t\\t\\t\\tGet-ChildItem $Path -ErrorAction SilentlyContinue -Filter $FileName -Recurse |\\n\\t\\t\\t\\tSort-Object FullName -Descending |\\n\\t\\t\\t\\tSelect -First 1\\n\\t\\t\\t\\t)\\n\\n\\t\\t\\tIf ($File)\\n\\t\\t\\t{\\n\\t\\t\\t\\tWrite-Debug (\\\"Found: {0}\\\" -f $File.FullName)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tReturn $File\\n}\\n\\n<#\\n .SYNOPSIS\\n Adds the required types so that they can be used\\n\\n .DESCRIPTION\\n Adds the DacFX types that are required to do database deploys, scripts and deployment reports from SSDT\\n\\n .EXAMPLE\\n Add-DACAssemblies\\n#>\\nFunction Add-DACAssemblies {\\n\\n\\tWrite-Verbose \\\"Loading the DacFX Assemblies\\\"\\n\\n\\t$SearchPathList = @(\\\"${env:ProgramFiles}\\\\Microsoft SQL Server\\\\$TargetDatabaseVersion\\\", \\\"${env:ProgramFiles(x86)}\\\\Microsoft SQL Server\\\\$TargetDatabaseVersion\\\")\\n\\n\\tWrite-Debug \\\"Searching for: Microsoft.SqlServer.TransactSql.ScriptDom.dll\\\"\\n\\t$ScriptDomDLL = (Find-DacFile -FileName \\\"Microsoft.SqlServer.TransactSql.ScriptDom.dll\\\" -PathList $SearchPathList)\\n\\n\\tWrite-Debug \\\"Searching for: Microsoft.SqlServer.Dac.dll\\\"\\n\\t$DacDLL = (Find-DacFile -FileName \\\"Microsoft.SqlServer.Dac.dll\\\" -PathList $SearchPathList)\\n\\n\\tif (($null -ne $ScriptDomDLL) -and ($null -ne $DacDLL))\\n    {\\n\\t\\tWrite-Debug (\\\"Adding the type: {0}\\\" -f $ScriptDomDLL.FullName)\\n\\t\\tAdd-Type -Path $ScriptDomDLL.FullName\\n\\n\\t\\tWrite-Debug (\\\"Adding the type: {0}\\\" -f $DacDLL.FullName)\\n\\t\\tAdd-Type -Path $DacDLL.FullName\\n    }\\n    else\\n    {\\n \\t\\t# Check to see if SqlServer module is installed\\n        if ((Get-ModuleInstalled -PowerShellModuleName \\\"SqlServer\\\") -ne $true)\\n        {\\n        \\t# Display message\\n            Write-Output \\\"PowerShell module SqlServer not present, downloading temporary copy ...\\\"\\n\\n            # Download and install temporary copy\\n            Install-PowerShellModule -PowerShellModuleName \\\"SqlServer\\\" -LocalModulesPath $LocalModules\\n        }\\n\\n\\t\\t# Display\\n    \\tWrite-Output \\\"Importing module SqlServer ...\\\"\\n\\n    \\t# Import the module\\n    \\tImport-Module -Name \\\"SqlServer\\\"\\n    \\n        #region Dependent assemblies\\n        Load-SqlServerAssmblies        \\n    }\\n\\n\\tWrite-Host \\\"Loaded the DAC assemblies\\\"\\n}\\n\\n\\n<#\\n .SYNOPSIS\\n Generates a connection string\\n\\n .DESCRIPTION\\n Derive a connection string from the supplied variables\\n\\n .PARAMETER ServerName\\n Name of the server to connect to\\n\\n .PARAMETER Database\\n Name of the database to connect to\\n\\n .PARAMETER UseIntegratedSecurity\\n Boolean value to indicate if Integrated Security should be used or not\\n\\n .PARAMETER UserName\\n User name to use if we are not using integrated security\\n\\n .PASSWORD Password\\n Password to use if we are not using integrated security\\n\\n .PARAMETER EnableMultiSubnetFailover\\n Flag as to whether we should enable multi subnet failover\\n\\n .EXAMPLE\\n Get-ConnectionString -ServerName localhost -UseIntegratedSecurity -Database OctopusDeploy\\n\\n .EXAMPLE\\n Get-ConnectionString -ServerName localhost -UserName sa -Password ProbablyNotSecure -Database OctopusDeploy\\n#>\\nFunction Get-ConnectionString {\\n\\tParam(\\n\\t\\t[Parameter(Mandatory=$True)]\\n\\t\\t[string]$ServerName,\\n\\t\\t[bool]$UseIntegratedSecurity,\\n\\t\\t[string]$UserName,\\n\\t\\t[string]$Password,\\n\\t\\t[bool]$EnableMultiSubnetFailover,\\n\\t\\t[string]$Database\\n\\t)\\n\\n\\t$ApplicationName = \\\"OctopusDeploy\\\"\\n\\t$connectionString = (\\\"Application Name={0};Server={1}\\\" -f $ApplicationName, $ServerName)\\n\\n\\tIf ($UseIntegratedSecurity)\\n\\t{\\n\\t\\tWrite-Verbose \\\"Using integrated security\\\"\\n\\t\\t$connectionString += \\\";Trusted_Connection=True\\\"\\n\\t}\\n\\tElse{\\n\\t\\tWrite-Verbose \\\"Using standard security\\\"\\n\\t\\t$connectionString += (\\\";Uid={0};Pwd={1}\\\" -f $UserName, $Password)\\n\\t}\\n\\n\\tif ($EnableMultiSubnetFailover)\\n\\t{\\n\\t\\tWrite-Verbose \\\"Enabling multi subnet failover\\\"\\n\\t\\t$connectionString += \\\";MultisubnetFailover=True\\\"\\n\\t}\\n\\n\\tIf ($Database)\\n\\t{\\n\\t\\t$connectionString += (\\\";Initial Catalog={0}\\\" -f $Database)\\n\\t}\\n\\n\\tReturn $connectionString\\n}\\n\\nFunction Get-SQLServerVersion {\\n    Param(\\n        [string]$serverVersion\\n    )\\n    \\n    $serverVersion = $serverVersion.Trim()\\n    \\n    Switch ($serverVersion){\\n\\t\\t\\\"100\\\" { Return \\\"SQL Server 2008\\\" }\\n\\t\\t\\\"110\\\" { Return \\\"SQL Server 2012\\\" }\\n\\t\\t\\\"120\\\" { Return \\\"SQL Server 2014\\\" }\\n\\t\\t\\\"130\\\" { Return \\\"SQL Server 2016\\\" }\\n        \\\"140\\\" { Return \\\"SQL Server 2017\\\" }\\n\\t\\tDefault { Return $null }\\n    }\\n}\\n\\n<#\\n .SYNOPSIS\\n Invokes the DacPac utility\\n\\n .DESCRIPTION\\n Used to invoke the actions against the DacFx library.  This utility can generate deployment reports, deployment scripts and execute a deploy\\n\\n .PARAMETER Report\\n Boolean flag as to whether a deploy report should be generated\\n\\n .PARAMETER Script\\n Boolean flag as to whether a deployment script should be generated\\n\\n .PARAMETER Deploy\\n Boolean flag as to whether a deployment should occur\\n\\n .PARAMETER DacPacFilename\\n Full path as to where we can find the DacPac to use\\n\\n .PARAMETER TargetServer\\n Name of the server to run the DacPac against\\n\\n .PARAMETER TargetDatabase\\n Name of the database to run the DacPac against\\n\\n .PARAMETER UseIntegratedSecurity\\n Flag as to whether we should use integrate security or not\\n\\n .PARAMETER EnableMultiSubnetFailover\\n Flag as to whether we should enable multi subnet failover\\n\\n .PARAMETER UserName\\n If we are not using integrated security, we should use this user name to connect to the server\\n\\n .PARAMETER Password\\n If we are not using integrated security, we should use this password to connect to the server\\n\\n .PARAMETER PublishProfile\\n Full path to the publish profile we should use\\n\\n .EXAMPLE\\n Invoke-DacPacUtility\\n\\n#>\\nFunction Invoke-DacPacUtility {\\n\\n\\tParam(\\n\\t\\t[bool]$Report,\\n\\t\\t[bool]$Script,\\n\\t\\t[bool]$Deploy,\\n\\t\\t[bool]$ExtractTargetDatabaseDacpac,\\n\\t\\t[string]$DacPacFilename,\\n\\t\\t[string]$TargetServer,\\n\\t\\t[string]$TargetDatabase,\\n\\t\\t[bool]$UseIntegratedSecurity,\\n\\t\\t[string]$UserName,\\n\\t\\t[string]$Password,\\n\\t\\t[bool]$EnableMultiSubnetFailover,\\n\\t\\t[string]$PublishProfile,\\n\\t\\t[string]$AdditionalDeploymentContributors,\\n\\t\\t[string]$AdditionalDeploymentContributorArguments\\n\\t)\\n\\n\\t# We output the parameters (excluding password) so that we can see what was supplied for debuging if required.  Useful for variable scoping problems\\n\\tWrite-Debug (\\\"Invoke-DacPacUtility called.  Parameter values supplied:\\\")\\n\\tWrite-Debug (\\\"    Dacpac Filename:                  {0}\\\" -f $DacPacFilename)\\n\\tWrite-Debug (\\\"    Dacpac Profile:                   {0}\\\" -f $PublishProfile)\\n\\tWrite-Debug (\\\"    Target server:                    {0}\\\" -f $TargetServer)\\n\\tWrite-Debug (\\\"    Target database:                  {0}\\\" -f $TargetDatabase)\\n\\tWrite-Debug (\\\"    Target database version:          {0}\\\" -f (Get-SQLServerVersion $TargetDatabaseVersion))\\n\\tWrite-Debug (\\\"    Using integrated security:        {0}\\\" -f $UseIntegratedSecurity)\\n\\tWrite-Debug (\\\"    Username:                         {0}\\\" -f $UserName)\\n\\tWrite-Debug (\\\"    Enable multi subnet failover      {0}\\\" -f $EnableMultiSubnetFailover)\\n\\tWrite-Debug (\\\"    Report:                           {0}\\\" -f $Report)\\n\\tWrite-Debug (\\\"    Script:                           {0}\\\" -f $Script)\\n\\tWrite-Debug (\\\"    Deploy:                           {0}\\\" -f $Deploy)\\n\\tWrite-Debug (\\\"    Extract target database dacpac    {0}\\\" -f $ExtractTargetDatabaseDacpac)\\n\\tWrite-Debug (\\\"    Deployment contributors:          {0}\\\" -f $AdditionalDeploymentContributors)\\n\\tWrite-Debug (\\\"    Deployment contributor arguments: {0}\\\" -f $AdditionalDeploymentContributorArguments)\\n\\n\\t$DateTime = ((Get-Date).ToUniversalTime().ToString(\\\"yyyyMMddHHmmss\\\"))\\n\\n    Add-DACAssemblies\\n\\n\\tTry {\\n\\t\\t$dacPac = [Microsoft.SqlServer.Dac.DacPackage]::Load($DacPacFilename)\\n\\t\\t$connectionString = (Get-ConnectionString -ServerName $TargetServer -Database $TargetDatabase -UseIntegratedSecurity $UseIntegratedSecurity -EnableMultiSubnetFailover $EnableMultiSubnetFailover -UserName $UserName -Password $Password)\\n\\n\\t\\t# Load the publish profile if supplied\\n\\t\\tIf ($PublishProfile)\\n\\t\\t{\\n\\t\\t\\tWrite-Verbose (\\\"Attempting to load the publish profile: {0}\\\" -f $PublishProfile)\\n\\n\\t\\t\\t#Load the publish profile\\n\\t\\t\\t$dacProfile = [Microsoft.SqlServer.Dac.DacProfile]::Load($PublishProfile)\\n\\t\\t\\tWrite-Verbose (\\\"Loaded publish profile: {0}\\\" -f $PublishProfile)\\n\\n            if([string]::IsNullOrWhiteSpace($dacProfile.TargetConnectionString) -ne $true) {\\n               Write-Warning \\\"Publish profile contains a TargetConnectionString setting. This setting might override the connection settings specified as command line parameters when using .NET classes from the Microsoft.SqlServer.Dac namespace.\\\"\\n            }\\n\\n\\t\\t\\t#Load the artifact back into Octopus Deploy\\n\\t\\t\\t$profileArtifact = Remove-InvalidFileNameChars -FileName (\\\"{0}.{1}.{2}.{3}\\\" -f $TargetServer, $TargetDatabase, $DateTime, ($PublishProfile.Remove(0, $PublishProfile.LastIndexOf(\\\"\\\\\\\") + 1)))\\n\\t\\t\\tNew-OctopusArtifact -Path $PublishProfile -Name $profileArtifact\\n\\t\\t\\tWrite-Verbose (\\\"Loaded publish profile as an Octopus Deploy artifact\\\")\\n\\t\\t}\\n\\t\\tElse {\\n\\t\\t\\t$dacProfile = New-Object Microsoft.SqlServer.Dac.DacProfile\\n\\t\\t\\tWrite-Verbose (\\\"Created blank publish profile\\\")\\n\\t\\t}\\n\\n\\t\\t# Specify additional deployment contributors:\\n\\t\\tif($AdditionalDeploymentContributors) {\\n\\t\\t    $dacProfile.DeployOptions.AdditionalDeploymentContributors = $AdditionalDeploymentContributors\\n\\t\\t}\\n\\t\\t\\n\\t\\tif($AdditionalDeploymentContributorArguments) {\\n\\t\\t    $dacProfile.DeployOptions.AdditionalDeploymentContributorArguments = $AdditionalDeploymentContributorArguments\\n\\t\\t}\\n\\n\\t\\t$dacServices = New-Object Microsoft.SqlServer.Dac.DacServices -ArgumentList $connectionString\\n\\n\\t\\t# Register the object events and output them to the verbose stream\\n\\t\\tRegister-ObjectEvent -InputObject $dacServices -EventName \\\"ProgressChanged\\\" -SourceIdentifier \\\"ProgressChanged\\\" -Action { Write-Verbose (\\\"DacServices: {0}\\\" -f $EventArgs.Message) } | Out-Null\\n\\t\\tRegister-ObjectEvent -InputObject $dacServices -EventName \\\"Message\\\" -SourceIdentifier \\\"Message\\\" -Action { Write-Host ($EventArgs.Message.Message) } | Out-Null\\n\\n\\t\\t# Get all SqlCmdVariables\\n        $sqlCmdVariables = $OctopusParameters.Keys -imatch \\\"SqlCmdVariable.*\\\"\\n        \\n        # Check to see if something is there\\n        if ($null -ne $sqlCmdVariables)\\n        {\\n        \\tWrite-Output \\\"Adding SqlCmdVariables ...\\\"\\n            \\n            # Check to see if the deploy options property is null\\n            if ($null -eq $dacProfile.DeployOptions)\\n            {\\n            \\t# Create new Microsoft.SqlServer.Dac.DacDeployOptions object\\n                $dacProfile.DeployOptions = New-Object Microsoft.SqlServer.Dac.DacDeployOptions\\n            }\\n            \\n            # Loop through the variable collection\\n            foreach ($sqlCmdVariable in $sqlCmdVariables)\\n            {\\n            \\t# Add variable to the deploy options\\n                $sqlCmdVariableKey = $sqlCmdVariable.Substring(($sqlCmdVariable.ToLower().IndexOf(\\\"sqlcmdvariable.\\\") + \\\"sqlcmdvariable.\\\".Length))\\n                \\n                Write-Output \\\"Adding variable: $sqlCmdVariableKey with value: $($OctopusParameters[$sqlCmdVariable])\\\"\\n                \\n                $dacProfile.DeployOptions.SqlCommandVariableValues.Add($sqlCmdVariableKey, $OctopusParameters[$sqlCmdVariable])\\n            }\\n        }\\n\\t\\n\\t\\tIf ($Report -or $Script -or $ExtractTargetDatabaseDacpac)\\n\\t\\t{\\n\\t\\t\\t# Extract a DACPAC so we can do reports and scripting faster (if both are done)\\n\\t\\t\\t# dbDacPac\\n\\t\\t\\t$dbDacPacFilename = Remove-InvalidFileNameChars -FileName (\\\"{0}.{1}.{2}.dacpac\\\" -f $TargetServer, $TargetDatabase, $DateTime)\\n            \\n            $dbDacPacFilepath = $InstallPath + \\\"\\\\\\\" + $dbDacPacFilename\\n\\t\\t\\t$dacVersion = New-Object System.Version(1, 0, 0, 0)\\n\\t\\t\\tWrite-Debug \\\"Extracting target server dacpac\\\"\\n\\t\\t\\t\\n            # Extract-Method needs full file-path in order to work\\n            $dacServices.Extract($dbDacPacFilepath, $TargetDatabase, $TargetDatabase, $dacVersion)\\n\\n\\t\\t\\tWrite-Debug (\\\"Loading the target server dacpac for report and scripting. Filename: {0}\\\" -f $dbDacPacFilepath)\\n\\t\\t\\t$dbDacPac = [Microsoft.SqlServer.Dac.DacPackage]::Load($dbDacPacFilepath)\\n\\n\\t\\t\\tIf ($ExtractTargetDatabaseDacpac)\\n\\t\\t\\t{\\n\\t\\t\\t\\tNew-OctopusArtifact -Path $dbDacPacFilepath -Name $dbDacPacFilepath\\n\\t\\t\\t}\\n\\n\\t\\t\\t# Generate a Deploy Report if one is asked for\\n\\t\\t\\tIf ($Report)\\n\\t\\t\\t{\\n\\t\\t\\t\\tWrite-Host (\\\"Generating deploy report against server: {0}, database: {1}\\\" -f $TargetServer, $TargetDatabase)\\n\\t\\t\\t\\t$deployReport = [Microsoft.SqlServer.Dac.DacServices]::GenerateDeployReport($dacPac, $dbDacPac, $TargetDatabase, $dacProfile.DeployOptions)\\n\\t\\t\\t\\t$reportArtifact = Remove-InvalidFileNameChars -FileName (\\\"{0}.{1}.{2}.{3}\\\" -f $TargetServer, $TargetDatabase, $DateTime, \\\"DeployReport.xml\\\")\\n\\t\\t\\n\\t\\t\\t\\tSet-Content $reportArtifact $deployReport\\n\\n\\t\\t\\t\\tWrite-Host (\\\"Loading the deploy report to OctopusDeploy: {0}\\\" -f $reportArtifact)\\n\\t\\t\\t\\tNew-OctopusArtifact -Path $reportArtifact -Name $reportArtifact\\n\\t\\t\\t}\\n\\n\\t\\t\\t# Generate a Deploy Script if one is asked for\\n\\t\\t\\tIf ($Script)\\n\\t\\t\\t{\\n\\t\\t\\t\\tWrite-Host (\\\"Generating deploy script against server: {0}, database: {1}\\\" -f $TargetServer, $TargetDatabase)\\n\\t\\t\\t\\t$deployScript = [Microsoft.SqlServer.Dac.DacServices]::GenerateDeployScript($dacPac, $dbDacPac, $TargetDatabase, $dacProfile.DeployOptions)\\n\\t\\t\\t\\t$scriptArtifact = Remove-InvalidFileNameChars -FileName (\\\"{0}.{1}.{2}.{3}\\\" -f $TargetServer, $TargetDatabase, $DateTime, \\\"DeployScript.sql\\\")\\n\\t\\t\\n\\t\\t\\t\\tSet-Content $scriptArtifact $deployScript\\n\\t\\t\\n\\t\\t\\t\\tWrite-Host (\\\"Loading the deploy script to OctopusDeploy: {0}\\\" -f $scriptArtifact)\\n\\t\\t\\t\\tNew-OctopusArtifact -Path $scriptArtifact -Name $scriptArtifact\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\t# Deploy the dacpac if asked for\\n\\t\\tIf ($Deploy)\\n\\t\\t{\\n\\t\\t\\tWrite-Host (\\\"Starting deployment of dacpac against server: {0}, database: {1}\\\" -f $TargetServer, $TargetDatabase)\\n\\t\\t\\t$dacServices.Deploy($dacPac, $TargetDatabase, $true, $dacProfile.DeployOptions, $null)\\n\\t\\t\\n\\t\\t\\tWrite-Host (\\\"Dacpac deployment complete\\\")\\n\\t\\t}\\n\\t\\t\\n\\t\\tUnregister-Event -SourceIdentifier \\\"ProgressChanged\\\"\\n\\t\\tUnregister-Event -SourceIdentifier \\\"Message\\\"\\n\\t}\\n\\tCatch {\\n\\t\\t# If we use Write-Error here the original exception will be overwritten by a WriteErrorException\\n        Write-Debug (\\\"An exception of type {0} was thrown.\\\" -f $_.Exception.GetType().FullName)\\n        Write-Debug (\\\"Deployment failed: {0} `r`nReason: {1}\\\" -f $_.Exception.Message, $_.Exception.InnerException.Message)\\n\\n        # re-throw in order to not lose inner exceptions and stack trace that are generated by\\n        # the invocation of the .NET classes from Microsoft.SqlServer.Dac\\n        throw\\n\\t}\\n}\\n\\n<#\\n.SYNOPSIS\\n    Determines the install location of the DACPAC package.\\n.DESCRIPTION\\n    Determines the install location of the DACPAC package.\\n.PARAMETER PackageStepName\\n    The name of the package step which installs the DACPAC.\\n#>\\nfunction Get-DacpacInstallPath\\n{\\n    [CmdletBinding()]\\n    Param\\n    (\\n        [Parameter(Mandatory=$true)]\\n        [String]$PackageStepName\\n    )\\n\\n    try\\n    {\\n        # Attempt to retrieve the install path from the package step.\\n        $InstallPathKey = (\\\"Octopus.Action[{0}].Output.Package.InstallationDirectoryPath\\\" -f $DACPACPackageStep)\\n        $InstallPath = $OctopusParameters[$InstallPathKey]\\n        if ($InstallPath -ne $null) {\\n            Write-Verbose (\\\"Install path determined from '{0}' output variables as '{1}'.\\\" -f $PackageStepName, $InstallPath)\\n            return $InstallPath\\n        }\\n\\n        # Install path hasn't been found yet so try to determine the path from the parameters of the package step.\\n        $InstallPathCustomDirectoryKey = (\\\"Octopus.Action[{0}].Package.CustomInstallationDirectory\\\" -f $DACPACPackageStep)\\n        $InstallPath = $OctopusParameters[$InstallPathCustomDirectoryKey]\\n        if ($InstallPath -ne $null) {\\n            Write-Verbose (\\\"Install path determined from '{0}' custom installation directory parameter as '{1}'.\\\" -f $PackageStepName, $InstallPath)\\n            return $InstallPath\\n        }\\n\\n        # Install path hasn't been found yet so try to determine the path from the parameters of the package step.\\n        $PackageIdKey = (\\\"Octopus.Action[{0}].Package.PackageId\\\" -f $DACPACPackageStep)\\n        $PackageId = $OctopusParameters[$PackageIdKey]\\n\\n        $PackageVersionKey = (\\\"Octopus.Action[{0}].Package.PackageVersion\\\" -f $DACPACPackageStep)\\n        $PackageVersion = $OctopusParameters[$PackageVersionKey]\\n\\n        if ($PackageVersion -ne $null -and $PackageId -ne $null) {\\n            $AgentApplicationDirectoryPath = $OctopusParameters[\\\"Octopus.Tentacle.Agent.ApplicationDirectoryPath\\\"]\\n            $TenantName = $OctopusParameters[\\\"Octopus.Deployment.Tenant.Name\\\"]\\n            $EnvironmentName = $OctopusParameters[\\\"Octopus.Environment.Name\\\"]\\n\\n            $InstallPath = Join-Path $AgentApplicationDirectoryPath \\\"$TenantName\\\\$EnvironmentName\\\\$PackageId\\\\$PackageVersion\\\"\\n\\n            Write-Verbose (\\\"Install path calculated using default path from '{0}' parameters as '{1}'.\\\" -f $PackageStepName, $InstallPath)\\n            return $InstallPath\\n        }\\n\\n        throw \\\"Could not determine the install location of the package.\\\"\\n    }\\n    catch\\n    {\\n        $_ | Format-List -Force | Out-String | Write-Debug;\\n        throw;\\n    }\\n}\\n\\n# Define PowerShell Modules path\\n$LocalModules = (New-Item \\\"$PSScriptRoot\\\\Modules\\\" -ItemType Directory -Force).FullName\\n$env:PSModulePath = \\\"$LocalModules;$env:PSModulePath\\\"\\n\\n# Get the supplied parameters\\n$DACPACPackageStep = $OctopusParameters[\\\"DACPACPackageStep\\\"]\\n$DACPACPackageName = $OctopusParameters[\\\"DACPACPackageName\\\"]\\n$PublishProfile = $OctopusParameters[\\\"DACPACPublishProfile\\\"]\\n$Report = Format-OctopusArgument -Value $OctopusParameters[\\\"Report\\\"]\\n$Script = Format-OctopusArgument -Value $OctopusParameters[\\\"Script\\\"]\\n$Deploy = Format-OctopusArgument -Value $OctopusParameters[\\\"Deploy\\\"]\\n$ExtractTargetDatabaseDacpac = Format-OctopusArgument -Value $OctopusParameters[\\\"ExtractTargetDatabaseDacPac\\\"]\\n$TargetServer = $OctopusParameters[\\\"TargetServer\\\"]\\n$TargetDatabase = $OctopusParameters[\\\"TargetDatabase\\\"]\\n$TargetDatabaseVersion = $OctopusParameters[\\\"TargetDatabaseVersion\\\"]\\n$UseIntegratedSecurity = Format-OctopusArgument -Value $OctopusParameters[\\\"UseIntegratedSecurity\\\"]\\n$Username = $OctopusParameters[\\\"SQLUsername\\\"]\\n$Password = $OctopusParameters[\\\"SQLPassword\\\"]\\n$EnableMultiSubnetFailover = Format-OctopusArgument -Value $OctopusParameters[\\\"EnableMultiSubnetFailover\\\"]\\n$AdditionalDeploymentContributors = Format-OctopusArgument -Value $OctopusParameters[\\\"AdditionalContributors\\\"]\\n$AdditionalDeploymentContributorArguments = Format-OctopusArgument -Value $OctopusParameters[\\\"AdditionalContributorArguments\\\"]\\n\\n$InstallPath = Get-DacpacInstallPath -PackageStepName $DACPACPackageStep\\nif(!(Test-Path $InstallPath)) {\\n    Throw (\\\"The package extraction folder '{0}' does not exist or the Octopus Tentacle does not have permission to access it.\\\" -f $InstallPath)\\n}\\n\\n# Expand the publish dacpac filename\\n$DACPACPackageName = ($InstallPath + \\\"\\\\\\\" + $DACPACPackageName)\\nif(!(Test-Path $DACPACPackageName)) {\\n    Throw (\\\"Could not find the file '{0}'\\\" -f $DACPACPackageName)\\n}\\n\\n# Expand the publish profile filename if a value has been supplied\\nIf ($PublishProfile)\\n{\\n    $PublishProfile = ($InstallPath + \\\"\\\\\\\" + $PublishProfile)\\n    if(!(Test-Path $PublishProfile)) {\\n        Throw (\\\"Could not find the file '{0}'\\\" -f $PublishProfile)\\n    }\\n}\\n\\n# Invoke the DacPac utility\\ntry\\n{\\n    Invoke-DacPacUtility -Report $Report -Script $Script -Deploy $Deploy -ExtractTargetDatabaseDacpac $ExtractTargetDatabaseDacpac -DacPacFilename $DACPACPackageName -TargetServer $TargetServer -TargetDatabase $TargetDatabase -UseIntegratedSecurity $UseIntegratedSecurity -Username $Username -Password $Password -EnableMultiSubnetFailover $EnableMultiSubnetFailover -PublishProfile $PublishProfile -AdditionalDeploymentContributors $AdditionalDeploymentContributors -AdditionalDeploymentContributorArguments $AdditionalDeploymentContributorArguments\\n}\\ncatch\\n{\\n    Write-Host $_.Exception.ToString()\\n    throw;\\n}\\n\",\n     \"Octopus.Action.Script.ScriptSource\": \"Inline\",\n     \"Octopus.Action.RunOnServer\": \"false\"\n   },\n@@ -191,8 +191,8 @@\n   ],\n   \"LastModifiedBy\": \"twerthi\",\n   \"$Meta\": {\n-    \"ExportedAt\": \"2019-08-15T19:02:46.349Z\",\n-    \"OctopusVersion\": \"2019.7.8\",\n+    \"ExportedAt\": \"2019-11-05T17:23:22.246Z\",\n+    \"OctopusVersion\": \"2019.10.2\",\n     \"Type\": \"ActionTemplate\"\n   },\n   \"Category\": \"sql\""}]